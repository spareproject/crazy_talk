###############################################################################################################################################################################################################

###############################################################################################################################################################################################################
/mnt
  /container
  /luks
  /mount
  /rawfs
  /storage
  /tmpfs
  /xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.luks
  /xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx.rawfs

unlock -
maps container key set
creates tmpfs < - needs to check for preexisting... probably a decent time to resolv revoke address and check?
random generate sign and import gnupg keyring

lock -
umaps the container key set - all encrypted rawfs are locked
leaves tmp signed key for networking up for anything running
if wiped and reinstalled it should QQ that it cant sign any of the container keys...
^ if locked cant install anything... can but your screwed for network access... requires unlock
^^ key generation should fail needs to hard block install or script a second key gen for container or key refresh

setup - ( see below for a better layout im getting name conflicts key tracking problems etc etc need to re iterate it once i get what the fuck im even doing)
generate root,persistent import host persistent sign 
host signs internal root and persistent (no import - clean keyrings rng for dirty stuff)

install -
create root,persistent container keys import container persistent key sign container persistent

start -
create a rng gnupg keyring for the running container sign it with the container keys

###############################################################################################################################################################################################################

top level one set of keys to handle every node in the cluster... (the fuck on that multiple admin key sets with restricted access linking is far to much for me to do alone)

/host
  /gnupg
    /persistent
    /revoke
    /root
    /persistent.public
    /persistent.sig
    /revoke.public
    /root.public

one to many relationship
multibooting host and creating multiple signed internal key rawfs setups

/internal
  /gnupg
    /persistent
    /revoke
    /root
    /persistent.public
    /persistent.sig
    /revoke.public
    /root.public

    /persistent.host.sig  - host persistent signed
    /revoke.host.sig      - host persistent signed
    /root.host.sig        - host persistent signed

    /import persistent.host - import host persistent
    /import revoke.host     - import host revoke
    /import root.host       - import host root

one to many relationship
creating multiple signed container key setups

/container
  /gnupg
    /persistent
    /revoke
    /root
    /persistent.public
    /persistent.sig
    /revoke.public
    /root.public

    /persistent.internal  - internal persistent signed
    /revoke.internal      - internal persistent signed
    /root.internal        - internal persistent signed

    /import persistent.internal - import internal persistent
    /import revoke.internal     - import internal revoke
    /import root.inernal        - import internal root

###############################################################################################################################################################################################################

so you boot...

first boot... generates and signs all the throw up keys 

setup... generates an internal key set locked with the host persistent key

unlock... unlocks the internal key set... and generates the throw up keys used for the container network

install... generates a container key set...
start... random generates the throw up keys user for the container network

root is sign only... really needs to be locked in some physical security doesnt do any key imports etc
persistent... encrypt and sign... still a clean keyring no imports
rng... holds all the shit needs to import and delete based on nodes going up / down its all tmpfs so if it goes tits up just reboot :D
^ tmpfs isnt inifinte so thats going to be a problem but for now we'll pretend we dont give any fucks

###############################################################################################################################################################################################################

so its all passwordless i cant debug or build any of this crap trying to memorize about 30 12 char length passwords... nor would i want to
host gets unplug security, one owned node doesnt get the network because the keys shouldnt be there...
internal holds its own keyset if it gets owned attackers can start bruteforcing root and persistent...
^ i could literally price how long this would take time vs cost for any given password length on aws or any other vps provider if you really want 
just to prove some hard numbers at how shit human memorable length is but /shrug no one believes me when i say this shit anyway

so if a host cluster node goes down entire container comms is compromised based on gnupg keyring bruteforce time...
still requires usb host key set to get access to the network or refresh keys etc... 
need to start laying out level of owned logic and dumping revoke check points etc....

basically i would have internal as nfc read write nfc ring has 1000 bytes now? cough cough :P to unlock 
container level as selling access to some scrub that just doesnt get security and how terrabad it all really is
split host cluster nodes by admin to number of boxes managed or pretty much whatever /shrug
i have no real direction with this 

was only really interested in a teaching tool / having a bit of fun and nursing my epeen knowing how all this crap actually works

building infrastructure to be run by many people vs building it to be run by one... and the total single point failure that is

###############################################################################################################################################################################################################

want a 10 line buffer cat strip a-zA-Z0-9
that can be auto used as a reply to the container 'backdoor' haha
basically i want, boot a load of containers, for i in included, do execute, cat or tail -f a socket with 10 line buffer to view any output on return address
its running none graphical just a server want to execute systemd-run doesnt do output...
gpg -r remote_host.container_name -e <<< "systemctl status nginx"  > /dev/udp/192.168.1.123/24 
netcat 2&>1 | sed 2 |1 gpg -d | bash > /dev/udp/2/port
basically i keep thinking o but systemd can already do that and i dont give any fucks i want remote not local the d's testing network host network is live

###############################################################################################################################################################################################################

scribbley bit...

i needed to make the container.rawfs and .luks the part uuid so i can rotate usbs with unique ./key.sh generated partitions 
else i update it to a bricked state and QQ that i cant rebuild anything... wouldnt be the first time 

host persistent signs internal persistent 
dumps host keys into internal persistent

internal needs the host root key and host persistent key...
root public incase persistent is revoked and changed...
and persistent as its default key exchange 

so host persistent signs internal root... 

it being signed is as good as it being added to the keyring... but persistent is empty level its a live network / usb / iso thing so all the rng keyrings get the shit bloat
i can ssh to a new node go give me your internal key set... it says you signed root and persistent to check auth...

i get some random shit rng host key its signed by persistent

host checking internal random key to talk to containers...
  give me the key in use...
  its signed by persistent...
  give me persistent signed by my key
  give me root signed by me key

nah im missing a double sig...
give me rng signed by persistent 
give me persistent signed by rng 
give me both those publics signed by me...

###############################################################################################################################################################################################################

erm i can barely see out of my bleeding cancerous eye sockets let alone be bothered to proof read this
^ need drugs so i can go wander around in blissful ignorance outside or a shimano rear cassette lock key and fast single track... hmmm
was more to attempt to explain this to myself because wtf mode just kicked in when trying to make netcat sockets...

speaking of...
nc -vulnzp 31279 2>/dev/null|gpg -d --allow-multiple-messages 2>/dev/null|/usr/bin/bash
^ means the public key becomes the private remote execute key... so logic ? 1. dont keep it on the container
host script to talk to containers needs to append 
gpg -r internal.persistent.public <<< /dev/stdout > /dev/udp/return_ip/31279
thats view only so careface at public key it can be tr stripped

internal can just host the rng key signed by persistent and root... nc -lu < key 
containers get root key to check its sig or something...
containers scrape key on boot can talk to host

need to define ports and the actual functionality i want

im just giving up with this for now 
will work it out tomorrow after coffee < - still totally a drug

###############################################################################################################################################################################################################
